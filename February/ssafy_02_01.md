# 순차 검색(Sequential Search)

* 일렬로 되어 있는 자료를 순서대로 검색하는 방법
    * 가장 간단하고 직관적인 검색 방법
    * 배열이나 연결 리스트 등 순차구조로 구현된 자료구조에서 원하는 항목을 찾을 때 유용
    * 알고리즘이 단순하여 구현이 쉽지만, 검색 대상의 수가 많은 경우에는 수행시간이 급격히 증가하여 비효율적
 
* 2가지 경우
    * 정렬된 경우
    * 정렬 안된 경우
 
## 검색 과정

* 첫 번째 원소부터 순서대로 검색

* 끝까지 검색시에도 원소가 없을시 실패

* 검색 성공시 인덱스 값 반환


## 정렬되어 있지 않은 경우

* 찾고자 하는 원소의 순서에 따라 비교횟수 결정
    * 평균 비교 횟수 = (1/n)*(1+2+3+...n) = (n+1)/2
* 시간 복잡도: O(n)

<br>

# 이진 검색(Binary Search)

* 검색 과정
    1. 자료의 중앙 원소를 고른다
    2. 중앙 원소의 값과 찾고자 하는 목표 값을 비교
    3. 목표 값이 중앙 원소의 값보다 작으면 자료의 왼쪽 절반에 검색 수행
    4. 크다면 자료의 오른쪽 절반에 검색 수행
    5. 1~4번의 과정을 반복
 
* 구현
    * 검색 범위의 시작점, 종료점 이용하여 검색 반복 수행
    * 이진 검색의 경우, 자료에 삽입, 삭제 발생시 배열 상태를 항상 정렬시키는 추가 작업 필요
 
<br>

# 인덱스

* Database에서 유래한 용어로, 테이블에 대한 동작 속도를 높여주는 자료 구조. DB분야가 아닌 곳에서는 Look up table 등의 용어 사용

* 인덱스를 저장하는데 필요한 공간은 보통 테이블을 저장하는데 필요한 디스크 공간보다 작다. 보통 인덱스는 키-필드만 가지고, 세부 항목은 X

* 배열 사용 인덱스
    * 대량의 데이터를 매번 정렬하면 프로그램 반응이 느려진다. 성능 저하 해결을 위해 배열 인덱스 사용가능.
 
<br>

# 선택 정렬

* 흩어진 당구공을 정리할 때, 보통 가장 작은 숫자의 공부터 차례대로 한다. 이것이 선택 정렬의 예시다.

* 주어진 자료들의 가장 작은 원소부터 차례로 선택하며 위치를 교환
    * 앞서 살펴본 셀렉션 알고리즘을 전체 자료에 적용한 것
 
* 정렬 과정
    * 주어진 리스트 최솟값 찾기
    * 그 값을 맨 앞의 값과 교환
    * 시작점을 제외한 나머지에 같은 과정 시행

* 시간 복잡도: O(n**2)

<br>

# 셀렉션 알고리즘(Selection Algorithm)
