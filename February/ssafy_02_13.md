# Stack 2

## 계산기

1. 중위 표기식의 후위 표기식 변환 방법
    * 수식의 각 연산자에 대해 우선순위에 따라 괄호를 사용하여 다시 표현
    * 각 연산자를 그에 대응하는 오른쪽 괄호의 뒤로 이동
    * 괄호를 제거
  
```
# 예시

A * B - C / D
# 1
((A * B) - (C / D))

# 2
((A B) * (C D) /) -

# 3
AB * CD / -
```

2. 방법 2
    * 입력 받은 중위 표기식에서 토큰 읽기
    * 토큰이 피연산자일시 토큰 출력
    * 토큰이 연산자 일 때(괄호 포함) 이 토큰이 스택의 top에 저장된 연산자보다 우선순위가 높으면 push, 그렇지 않을 시 토큰의 우선순위보다 작을 때까지 pop후 연산자를 push
    * 토큰이 오른쪽 괄호이면 스택 top에 왼쪽 괄호가 올 때까지 pop하고 pop한 연산자 출력, 왼쪽 괄호일시 pop만 하고 출력은 X
    * 중위 표기식에 읽을 것이 없다면 중지, 더 읽을 것이 있다면 1부터 반복
    * 스택에 남아 있는 연산자를 모두 pop하여 출력

<br>  

# 백트래킹

* 모든 후보를 검사하는 건 아님

## 백트래킹 기법

* 어떤 노드의 유망성을 점검한 후에 유망하지 않다고 결정되면 그 노드의 부모로 되돌아가(backtracking) 다음 자식 노드로 감

* 어떤 노드를 방문하였을 때 그 노드를 포함한 경로가 해답이 될 수 없다면 그 노드는 유망하지 않고, 해답의 가능성이 있으면 유망하다

* 가지치기(pruning): 유망하지 않는 노드가 포함되는 경로는 고려 x

## 백트래킹 알고리즘은 다음 절차를 따른다

1. 상태 공간 트리의 깊이 우선 검색 실시

2. 각 노드의 유망성 검사

3. 만일 그 노드가 유망하지 않을 시 부모 노드로 돌아가 검색 계속

```python
# 일반 백트래킹 알고리즘
def checknode(v):  # node
    if promising(v):
        if there is a solution at v:
            write the solution
    else:
        for u in each child of v:
            checknode(u)
```

## 깊이 우선 검색 vs 백트래킹

* 순수한 깊이 우선 검색 = 155 노드

* 백트래킹 = 27 노드