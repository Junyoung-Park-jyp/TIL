# 카운팅 정렬(Counting Sort)

* 항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업을 하여, 선형 시간에 정렬하는 효율적인 알고리즘

* 제한 사항
    * 정수나 정수로 표현할 수 있는 자료에 대해서만 적용 가능: 각 항목의 발생 회수를 기록하기 위해, 정수 항목으로 인덱스되는 카운트들의 배열 사용이 이유
    * 카운트들을 위한 충분한 공간을 할당하기 위해 집합 내의 가장 큰 정수를 알아야 함

* 시간 복잡도: O(n + k) n은 리스트 길이, k는 정수의 최댓값

<br>

## 카운팅 정렬 과정

* \[0, 4, 1, 3, 1, 2, 4, 1] 을 카운팅 정렬하는 과정

1. Data에서 각 항목들의 발생 횟수를 세고, 정수 항목들로 직접 인덱스 되는 카운트 배열 counts에 저장한다.

2. 정렬된 집합에서 각 항목의 앞에 위치한 항목 개수 반영(카운트의 원소들을 누적)해 원소를 조정함.
    * 구간의 합, 구간의 원소 개수 측정 등에 사용 가능

3. 원본과 길이가 같은 빈 리스트 Temp를 만든다. 그 후 counts\[1]을 감소시키고 Temp에 1을 삽입한다.
    * 위치는 index3, 4번째로 그 이유는 1은 최소한 4번째 위치에는 나타난다(0과 1 개수의 합이 4이므로)
    * 마찬가지로 counts\[4] 감소 후 마지막 위치에 4를 넣는다.(4는 최대의 값이므로)
    * 같은 수들은, 원본의 순서를 유지한 채로 정렬된다.

```python
def counting_sort(data):
    k = max(data)
    counts = [0] * (k+1)
    temp = [0] * len(data)

    for num in data:
        counts[num] += 1

    for num in range(1, k+1):
        counts[num] += counts[num - 1]

    for num in range(len(data)-1, -1, -1):
        counts[data[num]] -= 1
        temp[counts[data[num]]] = data[num]

    return temp

data = list(map(int, input().split()))
print(counting_sort(data))
```

<br>

## Baby-gin Game

* 0~9 사이의 숫자 카드에서 임의의 카드 6장을 뽑을 때, 3장의 카드가 연속적인 번호면 run, 동일한 번호면 triplet

* 그리고 6장의 카드가 run과 triplet로만 구성된 경우를 baby-gin으로 부른다

* 6자리 숫자를 입력 받아 baby-gin 여부를 판단하는 프로그램을 작성하라

<br>

# 완전 검색(Exaustive Search)

* 완전 검색 방법은 문제의 해법으로 생각할 수 있는 모든 경우의 수를 나열하고 확인하는 기법

* Brute-force 혹은 generate-and-test 기법으로 불림

* 모든 경우의 수 테스트, 최종 해법 도출

* 일반적으로 경우의 수가 상대적으로 적어야 유용

## 완전 검색으로 시작하라

* 모든 경우의 수를 생성하고 테스트하기 때문에 수행속도는 느려도 해답을 찾을 확률 높음

* 자격검정평가에서도 우선 완전 검색으로 해답을 도출 후, 성능 개선을 위해 다른 알고리즘을 사용하는게 바람직

* 6개의 숫자로 만들 수 있는 모든 숫자 나열(중복 포함)
    * 예) 입력으로 \[2, 3, 5, 7, 7, 7] 을 받을 시, 나오는 순열

<br>

# 탐욕(그리디) 알고리즘

* 그리디는 최적해를 구하는 데 사용하는 근시안적 방법

* 여러 경우 중 하나를 결정할 때마다 그 순간에 최적인 방식을 선택해서 최종적 해답에 도달

* 각 선택의 시점은 지역적으로 최적이지만, 선택들이 모인 최종 해답이 최적인 보장은 없다

* 일반적으로 검증 없이 생각을 바로 구현하면 그리디 알고리즘이 된다

## 그리디 알고리즘 동작 과정 

1. 해를 선택: 현재 상태의 부분적 최적 해를 구해 부분 해집합에 추가

2. 실행 가능성 검사: 새로운 부분 해집합이 실행 가능한지 확인

3. 해 검사: 새로운 부분 해집합이 문제의 해가 되는지 확인, 안될 경우 1번으로 회귀

<br>

## Baby-gin을 완전검색 이외의 법으로 풀어보자

* 6개의 숫자는 6자리의 정수 값으로 입력c

* count를 사용해보자

